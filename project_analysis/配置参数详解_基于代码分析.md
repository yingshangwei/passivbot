# Passivbot 配置参数详解 - 基于代码分析

## ⚠️ 重要声明

本文档基于对Passivbot源代码的深入分析，确保参数含义的准确性。所有参数说明都基于实际的代码实现，避免误导性推测。

## 📋 配置结构概览

Passivbot的配置文件采用JSON格式，主要包含以下几个部分：

```json
{
  "backtest": { ... },    // 回测配置
  "bot": { ... },         // 交易策略配置
  "live": { ... },        // 实盘交易配置
  "optimize": { ... },    // 参数优化配置
  "coin_overrides": { ... } // 币种特定覆盖配置
}
```

## 🔧 回测配置 (backtest)

### 基础设置
| 参数 | 类型 | 默认值 | 代码实现说明 |
|------|------|--------|--------------|
| `base_dir` | string | "backtests" | 回测结果存储目录 |
| `combine_ohlcvs` | boolean | true | 是否合并多个交易所的OHLCV数据 |
| `compress_cache` | boolean | true | 是否压缩缓存数据以节省磁盘空间 |
| `start_date` | string | "2020-04-01" | 回测开始日期 |
| `end_date` | string | "now" | 回测结束日期，'now'表示当前日期 |
| `starting_balance` | number | 100000 | 初始资金（USD） |
| `use_btc_collateral` | boolean | true | 是否使用BTC作为抵押品 |

### 交易所和数据设置
| 参数 | 类型 | 默认值 | 代码实现说明 |
|------|------|--------|--------------|
| `exchanges` | array | ["binance", "bybit"] | 使用的交易所列表 |
| `gap_tolerance_ohlcvs_minutes` | number | 120 | OHLCV数据间隙容忍度（分钟） |

## 🤖 交易策略配置 (bot)

### 策略结构
```json
{
  "bot": {
    "long": { ... },   // 多头策略参数
    "short": { ... }   // 空头策略参数
  }
}
```

## 📊 网格交易参数 - 基于代码分析

### 入场网格参数

#### entry_grid_spacing_pct (网格间距百分比)
**代码实现** (entries.rs:117, 140):
```rust
// 多头重新入场价格计算
let reentry_price = position_price * (1.0 - entry_grid_spacing_pct * (1.0 + multiplier));

// 空头重新入场价格计算  
let reentry_price = position_price * (1.0 + entry_grid_spacing_pct * (1.0 + multiplier));
```

**准确含义**：
- 决定相邻网格订单之间的价格距离
- 多头：价格向下移动时触发重新入场
- 空头：价格向上移动时触发重新入场
- 实际间距会根据仓位风险动态调整

#### entry_grid_spacing_weight (网格间距权重)
**代码实现** (entries.rs:113-114):
```rust
let multiplier = (wallet_exposure / wallet_exposure_limit) * entry_grid_spacing_weight;
```

**准确含义**：
- 根据当前仓位风险动态调整网格间距
- 当仓位风险增加时，网格间距会相应调整
- 用于实现动态网格间距策略

#### entry_grid_double_down_factor (加倍下注因子)
**代码实现** (entries.rs:96):
```rust
position_size.abs() * double_down_factor
```

**准确含义**：
- 决定下一次入场的数量倍数
- 基于当前仓位大小计算
- 用于实现Martingale策略的仓位管理

#### entry_initial_qty_pct (初始仓位比例)
**代码实现** (entries.rs:19):
```rust
balance * wallet_exposure_limit * entry_initial_qty_pct
```

**准确含义**：
- 初始入场的资金比例
- 基于钱包余额和风险敞口限制计算
- 决定第一次入场的仓位大小

#### entry_initial_ema_dist (初始EMA距离)
**代码实现** (utils.rs:243):
```rust
// 多头初始入场价格
ema_bands_lower * (1.0 - ema_dist)

// 空头初始入场价格  
ema_bands_upper * (1.0 + ema_dist)
```

**准确含义**：
- 相对于EMA带的偏移距离
- 多头：在EMA下轨下方入场
- 空头：在EMA上轨上方入场
- 用于确定初始入场价格

### 平仓网格参数

#### close_grid_markup_start (平仓网格起始标记)
**代码实现** (closes.rs:58, 66):
```rust
position.price * (1.0 + close_grid_markup_start)  // 多头
position.price * (1.0 - close_grid_markup_start)  // 空头
```

**准确含义**：
- 平仓网格的起始价格标记
- 多头：在成本价上方开始平仓
- 空头：在成本价下方开始平仓
- 决定第一个平仓订单的价格

#### close_grid_markup_end (平仓网格结束标记)
**代码实现** (closes.rs:70):
```rust
position.price * (1.0 + close_grid_markup_end)  // 多头
position.price * (1.0 - close_grid_markup_end)  // 空头
```

**准确含义**：
- 平仓网格的结束价格标记
- 与起始标记一起定义平仓价格范围
- 决定最后一个平仓订单的价格

#### close_grid_qty_pct (平仓数量比例)
**代码实现** (closes.rs:28):
```rust
full_psize * close_grid_qty_pct + leftover
```

**准确含义**：
- 每次平仓的数量比例
- 基于满仓大小计算
- 决定每个平仓订单的数量

## 🎯 追踪订单参数 - 基于代码分析

### 追踪入场参数

#### entry_trailing_threshold_pct (追踪入场阈值)
**代码实现** (trailing_flip.rs:76-78):
```rust
// 多头追踪条件
if highest_price_since_position_change > position_price * (1 + trailing_threshold_pct)

// 空头追踪条件  
if lowest_price_since_position_change < position_price * (1 - trailing_threshold_pct)
```

**准确含义**：
- 触发追踪入场的价格移动阈值
- 多头：价格向上移动超过阈值时启动追踪
- 空头：价格向下移动超过阈值时启动追踪
- 必须与回调条件同时满足才会下单

#### entry_trailing_retracement_pct (追踪入场回调比例)
**代码实现** (trailing_flip.rs:79-81):
```rust
// 多头回调条件
if lowest_price_since_highest < highest_price_since_position_change * (1 - trailing_retracement_pct)

// 空头回调条件
if highest_price_since_lowest > lowest_price_since_position_change * (1 + trailing_retracement_pct)
```

**准确含义**：
- 价格回调的百分比
- 在价格移动超过阈值后，等待回调触发入场
- 用于捕捉价格反转的时机

#### entry_trailing_double_down_factor (追踪入场加倍因子)
**代码实现** (entries.rs:96):
```rust
position_size.abs() * entry_trailing_double_down_factor
```

**准确含义**：
- 追踪入场时的数量倍数
- 与网格入场的加倍因子类似
- 决定追踪入场订单的数量

#### entry_trailing_grid_ratio (追踪入场网格比例)
**代码实现** (entries.rs: 追踪与网格的分配逻辑):
```rust
// 根据比例决定使用追踪订单还是网格订单
if trailing_grid_ratio > 0.0 {
    // 优先使用追踪订单
} else {
    // 优先使用网格订单
}
```

**准确含义**：
- 控制追踪订单和网格订单的分配比例
- 正值：优先使用追踪订单
- 负值：优先使用网格订单
- 用于平衡两种入场策略

### 追踪平仓参数

#### close_trailing_threshold_pct (追踪平仓阈值)
**代码实现** (closes.rs:131-136):
```rust
if close_trailing_threshold_pct <= 0.0 {
    // 立即开始追踪平仓
} else {
    // 等待价格移动超过阈值
}
```

**准确含义**：
- 触发追踪平仓的价格移动阈值
- 小于等于0时立即开始追踪
- 大于0时等待价格移动超过阈值

#### close_trailing_retracement_pct (追踪平仓回调比例)
**代码实现** (closes.rs:133-136):
```rust
if trailing_price_bundle.min_since_max < trailing_price_bundle.max_since_open * (1.0 - close_trailing_retracement_pct)
```

**准确含义**：
- 平仓时的价格回调百分比
- 在价格有利移动后，等待回调触发平仓
- 用于锁定利润的时机

#### close_trailing_qty_pct (追踪平仓数量比例)
**代码实现** (closes.rs:139-146):
```rust
calc_close_qty(..., close_trailing_qty_pct, ...)
```

**准确含义**：
- 追踪平仓时的数量比例
- 决定每次追踪平仓的数量
- 与网格平仓的数量比例类似

## 📈 EMA指标参数 - 基于代码分析

### ema_span_0, ema_span_1 (EMA周期)
**代码实现** (analysis.rs: EMA计算逻辑):
```rust
// EMA计算公式
next_EMA = prev_EMA * (1 - alpha) + new_val * alpha
alpha = 2 / (span + 1)
```

**准确含义**：
- 两个EMA的周期（以分钟为单位）
- 用于计算EMA带：`ema_band_lower = min(emas)`, `ema_band_upper = max(emas)`
- 多头通常使用较短周期，空头使用较长周期
- 用于确定入场价格和解套价格

## 🛡️ 风险管理参数 - 基于代码分析

### n_positions (最大仓位数量)
**代码实现** (passivbot.py: 仓位管理逻辑):
```rust
// 检查是否超过最大仓位数量
if current_positions >= n_positions {
    return Order::default();
}
```

**准确含义**：
- 允许的最大仓位数量
- 超过此数量时不再开新仓
- 用于控制总仓位数量

### total_wallet_exposure_limit (总钱包风险敞口限制)
**代码实现** (entries.rs:19, utils.rs: 风险计算):
```rust
balance * wallet_exposure_limit * entry_initial_qty_pct
```

**准确含义**：
- 总钱包的风险敞口限制
- 例如：2.0表示200%的风险敞口
- 每个仓位分配：`wallet_exposure_limit = total_wallet_exposure_limit / n_positions`

### enforce_exposure_limit (强制执行风险限制)
**代码实现** (passivbot.py: 风险检查逻辑):
```python
if enforce_exposure_limit and exposure > limit:
    # 强制平仓到限制范围内
```

**准确含义**：
- 是否强制执行风险限制
- 当仓位超过风险限制时，强制平仓
- 用于风险管理的最后防线

## 🔄 解套机制参数 - 基于代码分析

### unstuck_threshold (解套阈值)
**代码实现** (backtest.rs:1155):
```rust
if wallet_exposure / wallet_exposure_limit > unstuck_threshold {
    // 触发解套检查
}
```

**准确含义**：
- 触发解套检查的风险阈值
- 当仓位风险超过此阈值时，检查是否可以解套
- 例如：0.68表示68%的风险阈值

### unstuck_ema_dist (解套EMA距离)
**代码实现** (backtest.rs:1159, 1200):
```rust
// 多头解套价格
ema_bands.upper * (1.0 + unstuck_ema_dist)

// 空头解套价格  
ema_bands.lower * (1.0 - unstuck_ema_dist)
```

**准确含义**：
- 解套时的EMA带偏移距离
- 多头：在EMA上轨上方解套
- 空头：在EMA下轨下方解套
- 用于确定解套价格

### unstuck_loss_allowance_pct (解套损失容忍度)
**代码实现** (utils.rs:222-232):
```rust
let balance_peak = balance + (pnl_cumsum_max - pnl_cumsum_last);
let drop_since_peak_pct = balance / balance_peak - 1.0;
(balance_peak * (loss_allowance_pct + drop_since_peak_pct)).max(0.0)
```

**准确含义**：
- 允许的解套损失百分比
- 基于历史最高余额计算
- 用于控制解套时的最大损失

### unstuck_close_pct (解套平仓比例)
**代码实现** (backtest.rs:1241, 1294):
```rust
position.size * unstuck_close_pct
```

**准确含义**：
- 解套时平仓的数量比例
- 决定解套订单的数量
- 用于部分解套策略

## 🚀 实盘交易配置 (live) - 基于代码分析

### 基础设置
| 参数 | 类型 | 默认值 | 代码实现说明 |
|------|------|--------|--------------|
| `user` | string | "your_account_name" | 对应api-keys.json中的账户名 |
| `leverage` | number | 1.0 | 杠杆倍数 |
| `market_orders_allowed` | boolean | false | 是否允许市价单 |
| `time_in_force` | string | "GTC" | 订单有效期类型 |

### 币种管理
| 参数 | 类型 | 默认值 | 代码实现说明 |
|------|------|--------|--------------|
| `approved_coins` | array/string | ["BTCUSDT", "ETHUSDT"] | 允许交易的币种列表 |
| `ignored_coins` | object | {"long": [], "short": []} | 忽略的币种 |
| `minimum_coin_age_days` | number | 30 | 最小币种年龄（天） |
| `empty_means_all_approved` | boolean | false | 空列表是否表示全部允许 |

### 执行控制
| 参数 | 类型 | 默认值 | 代码实现说明 |
|------|------|--------|--------------|
| `execution_delay_seconds` | number | 0.0 | 执行延迟（秒） |
| `max_n_cancellations_per_batch` | number | 100 | 每批最大取消数量 |
| `max_n_creations_per_batch` | number | 100 | 每批最大创建数量 |
| `max_n_restarts_per_day` | number | 10 | 每日最大重启次数 |

## ⚙️ 参数优化配置 (optimize) - 基于代码分析

### 优化算法设置
| 参数 | 类型 | 默认值 | 代码实现说明 |
|------|------|--------|--------------|
| `iters` | number | 1000 | 优化迭代次数 |
| `population_size` | number | 50 | 种群大小 |
| `crossover_probability` | number | 0.7 | 交叉概率 |
| `mutation_probability` | number | 0.1 | 变异概率 |
| `n_cpus` | number | 4 | 使用的CPU核心数 |

### 优化边界 (bounds)
优化边界定义了每个参数的可搜索范围，基于代码中的参数验证逻辑：

```json
{
  "bounds": {
    "long_entry_grid_spacing_pct": [0.01, 0.05],
    "long_close_grid_markup_start": [0.001, 0.02],
    "long_n_positions": [3, 10]
  }
}
```

### 优化限制 (limits)
| 参数 | 类型 | 默认值 | 代码实现说明 |
|------|------|--------|--------------|
| `max_drawdown_pct` | number | 0.2 | 最大回撤限制 |
| `min_sharpe_ratio` | number | 0.5 | 最小夏普比率 |
| `min_total_return_pct` | number | 0.1 | 最小总收益率 |

## 📊 参数交互关系 - 基于代码分析

### 网格间距的动态调整
```rust
// 基于仓位风险的动态间距
let multiplier = (wallet_exposure / wallet_exposure_limit) * entry_grid_spacing_weight;
let actual_spacing = entry_grid_spacing_pct * (1.0 + multiplier);
```

### 仓位大小的计算
```rust
// 初始仓位大小
let initial_qty = balance * wallet_exposure_limit * entry_initial_qty_pct;

// 重新入场数量
let reentry_qty = position_size * entry_grid_double_down_factor;
```

### 平仓价格的确定
```rust
// 网格平仓价格
let close_price = position_price * (1.0 + close_grid_markup_start);

// 追踪平仓条件
if price_moved > threshold && price_retraced > retracement {
    // 执行追踪平仓
}
```

## ⚠️ 重要提醒

### 参数调优原则
1. **基于代码理解**：所有参数调整都应基于对代码逻辑的理解
2. **小步调整**：每次只调整一个参数，观察效果
3. **充分回测**：任何参数修改都要经过充分回测验证
4. **风险优先**：始终优先考虑风险控制

### 常见误区
1. **不要盲目调整**：基于推测调整参数可能导致严重损失
2. **理解参数交互**：参数之间存在复杂的交互关系
3. **注意市场适应性**：不同市场条件下参数效果可能不同
4. **定期验证**：定期验证参数的有效性

### 安全建议
1. **小资金测试**：先用小资金测试新参数
2. **监控风险指标**：持续监控风险指标
3. **备份配置**：定期备份有效的配置
4. **记录变化**：详细记录参数变化和效果

---

**文档版本**: v1.0 (基于代码分析)  
**分析基础**: Passivbot v7.3.20 源代码  
**更新时间**: 2025年9月6日  
**重要提醒**: 本文档基于实际代码分析，确保参数含义的准确性