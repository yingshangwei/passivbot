# Passivbot 自定义策略开发指南

## 当前策略架构分析

### 策略调用流程
```
Passivbot类 → 策略计算函数 → Rust组件 → 策略逻辑实现
```

### 关键调用点
1. **入场策略调用** (src/passivbot.py:1546):
```python
entries = getattr(pbr, f"calc_entries_{pside}_py")(...)
```

2. **平仓策略调用** (src/passivbot.py:1580):
```python
closes = getattr(pbr, f"calc_closes_{pside}_py")(...)
```

### Rust策略函数
- `calc_entries_long_py` - 多头入场策略
- `calc_entries_short_py` - 空头入场策略  
- `calc_closes_long_py` - 多头平仓策略
- `calc_closes_short_py` - 空头平仓策略

## 自定义策略实现方案

### 方案一：Python策略插件系统（推荐）

#### 1. 创建策略接口
```python
# src/strategies/base_strategy.py
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Tuple

class BaseStrategy(ABC):
    """策略基类"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.name = self.__class__.__name__
    
    @abstractmethod
    def calc_entries(self, pside: str, symbol: str, **kwargs) -> List[Dict]:
        """计算入场订单"""
        pass
    
    @abstractmethod
    def calc_closes(self, pside: str, symbol: str, **kwargs) -> List[Dict]:
        """计算平仓订单"""
        pass
    
    def get_strategy_params(self) -> Dict[str, Any]:
        """获取策略参数"""
        return self.config.get('strategy', {})
```

#### 2. 实现默认策略
```python
# src/strategies/default_strategy.py
from .base_strategy import BaseStrategy
import passivbot_rust as pbr

class DefaultStrategy(BaseStrategy):
    """默认网格+追踪策略"""
    
    def calc_entries(self, pside: str, symbol: str, **kwargs) -> List[Dict]:
        """使用Rust组件计算入场订单"""
        return getattr(pbr, f"calc_entries_{pside}_py")(
            kwargs['qty_steps'],
            kwargs['price_steps'],
            kwargs['min_qtys'],
            kwargs['min_costs'],
            kwargs['c_mults'],
            self.config_get(["bot", pside, "entry_grid_double_down_factor"]),
            # ... 其他参数
        )
    
    def calc_closes(self, pside: str, symbol: str, **kwargs) -> List[Dict]:
        """使用Rust组件计算平仓订单"""
        return getattr(pbr, f"calc_closes_{pside}_py")(
            kwargs['qty_steps'],
            kwargs['price_steps'],
            kwargs['min_qtys'],
            kwargs['min_costs'],
            kwargs['c_mults'],
            self.config_get(["bot", pside, "close_grid_markup_end"]),
            # ... 其他参数
        )
```

#### 3. 实现自定义策略示例
```python
# src/strategies/ma_crossover_strategy.py
import numpy as np
from .base_strategy import BaseStrategy

class MACrossoverStrategy(BaseStrategy):
    """移动平均线交叉策略"""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.fast_period = config.get('strategy', {}).get('fast_period', 10)
        self.slow_period = config.get('strategy', {}).get('slow_period', 20)
        self.position_size = config.get('strategy', {}).get('position_size', 0.1)
    
    def calc_entries(self, pside: str, symbol: str, **kwargs) -> List[Dict]:
        """基于MA交叉的入场逻辑"""
        orders = []
        
        # 获取价格数据
        prices = kwargs.get('prices', [])
        if len(prices) < self.slow_period:
            return orders
        
        # 计算移动平均线
        fast_ma = np.mean(prices[-self.fast_period:])
        slow_ma = np.mean(prices[-self.slow_period:])
        prev_fast_ma = np.mean(prices[-self.fast_period-1:-1])
        prev_slow_ma = np.mean(prices[-self.slow_period-1:-1])
        
        current_price = kwargs.get('current_price', 0)
        balance = kwargs.get('balance', 0)
        
        # 金叉买入信号
        if pside == 'long' and prev_fast_ma <= prev_slow_ma and fast_ma > slow_ma:
            qty = balance * self.position_size / current_price
            orders.append({
                'qty': qty,
                'price': current_price,
                'order_type': 'market_buy',
                'strategy': 'ma_crossover'
            })
        
        # 死叉卖出信号
        elif pside == 'short' and prev_fast_ma >= prev_slow_ma and fast_ma < slow_ma:
            qty = balance * self.position_size / current_price
            orders.append({
                'qty': -qty,
                'price': current_price,
                'order_type': 'market_sell',
                'strategy': 'ma_crossover'
            })
        
        return orders
    
    def calc_closes(self, pside: str, symbol: str, **kwargs) -> List[Dict]:
        """基于MA交叉的平仓逻辑"""
        orders = []
        
        # 获取当前仓位
        position_size = kwargs.get('position_size', 0)
        if abs(position_size) < 1e-8:
            return orders
        
        # 获取价格数据
        prices = kwargs.get('prices', [])
        if len(prices) < self.slow_period:
            return orders
        
        # 计算移动平均线
        fast_ma = np.mean(prices[-self.fast_period:])
        slow_ma = np.mean(prices[-self.slow_period:])
        prev_fast_ma = np.mean(prices[-self.fast_period-1:-1])
        prev_slow_ma = np.mean(prices[-self.slow_period-1:-1])
        
        current_price = kwargs.get('current_price', 0)
        
        # 多头平仓信号（死叉）
        if pside == 'long' and position_size > 0 and prev_fast_ma >= prev_slow_ma and fast_ma < slow_ma:
            orders.append({
                'qty': -position_size,
                'price': current_price,
                'order_type': 'market_sell',
                'strategy': 'ma_crossover'
            })
        
        # 空头平仓信号（金叉）
        elif pside == 'short' and position_size < 0 and prev_fast_ma <= prev_slow_ma and fast_ma > slow_ma:
            orders.append({
                'qty': abs(position_size),
                'price': current_price,
                'order_type': 'market_buy',
                'strategy': 'ma_crossover'
            })
        
        return orders
```

#### 4. 策略管理器
```python
# src/strategies/strategy_manager.py
from typing import Dict, Type
from .base_strategy import BaseStrategy
from .default_strategy import DefaultStrategy
from .ma_crossover_strategy import MACrossoverStrategy

class StrategyManager:
    """策略管理器"""
    
    def __init__(self):
        self.strategies: Dict[str, Type[BaseStrategy]] = {
            'default': DefaultStrategy,
            'ma_crossover': MACrossoverStrategy,
        }
        self.active_strategy: BaseStrategy = None
    
    def register_strategy(self, name: str, strategy_class: Type[BaseStrategy]):
        """注册新策略"""
        self.strategies[name] = strategy_class
    
    def load_strategy(self, name: str, config: Dict[str, Any]) -> BaseStrategy:
        """加载策略"""
        if name not in self.strategies:
            raise ValueError(f"Strategy '{name}' not found")
        
        strategy_class = self.strategies[name]
        self.active_strategy = strategy_class(config)
        return self.active_strategy
    
    def get_active_strategy(self) -> BaseStrategy:
        """获取当前活跃策略"""
        return self.active_strategy
```

#### 5. 修改Passivbot类
```python
# 在src/passivbot.py中添加策略支持
from strategies.strategy_manager import StrategyManager

class Passivbot:
    def __init__(self, config: dict):
        # ... 现有初始化代码 ...
        
        # 初始化策略管理器
        self.strategy_manager = StrategyManager()
        
        # 加载策略
        strategy_name = config.get('strategy', {}).get('name', 'default')
        self.strategy = self.strategy_manager.load_strategy(strategy_name, config)
    
    def update_orders(self, symbol: str):
        """更新订单 - 修改策略调用部分"""
        for pside in ["long", "short"]:
            if self.PB_modes[pside][symbol] in ["tp_only"] and not self.has_position(pside, symbol):
                pass
            elif self.PB_modes[pside][symbol] == "manual":
                pass
            else:
                # 使用策略管理器计算订单
                strategy = self.strategy_manager.get_active_strategy()
                
                # 准备策略参数
                strategy_kwargs = {
                    'qty_steps': self.qty_steps[symbol],
                    'price_steps': self.price_steps[symbol],
                    'min_qtys': self.min_qtys[symbol],
                    'min_costs': self.min_costs[symbol],
                    'c_mults': self.c_mults[symbol],
                    'balance': self.balance,
                    'position_size': self.positions[symbol][pside]["size"],
                    'position_price': self.positions[symbol][pside]["price"],
                    'current_price': self.get_last_price(symbol),
                    'prices': self.get_price_history(symbol),  # 需要实现
                    # ... 其他必要参数
                }
                
                # 计算入场订单
                entries = strategy.calc_entries(pside, symbol, **strategy_kwargs)
                
                # 计算平仓订单
                closes = strategy.calc_closes(pside, symbol, **strategy_kwargs)
                
                # 处理订单...
```

### 方案二：Rust策略扩展

#### 1. 创建Rust策略接口
```rust
// passivbot-rust/src/strategies/mod.rs
pub trait Strategy {
    fn calc_entries(&self, params: &StrategyParams) -> Vec<Order>;
    fn calc_closes(&self, params: &StrategyParams) -> Vec<Order>;
}

pub struct StrategyParams {
    pub qty_steps: f64,
    pub price_steps: f64,
    pub min_qtys: f64,
    pub min_costs: f64,
    pub c_mults: f64,
    pub balance: f64,
    pub position_size: f64,
    pub position_price: f64,
    pub current_price: f64,
    // ... 其他参数
}
```

#### 2. 实现自定义Rust策略
```rust
// passivbot-rust/src/strategies/ma_crossover.rs
use super::{Strategy, StrategyParams, Order, OrderType};

pub struct MACrossoverStrategy {
    pub fast_period: usize,
    pub slow_period: usize,
    pub position_size: f64,
}

impl Strategy for MACrossoverStrategy {
    fn calc_entries(&self, params: &StrategyParams) -> Vec<Order> {
        // 实现MA交叉策略逻辑
        vec![]
    }
    
    fn calc_closes(&self, params: &StrategyParams) -> Vec<Order> {
        // 实现MA交叉平仓逻辑
        vec![]
    }
}
```

### 方案三：配置文件驱动策略

#### 1. 策略配置示例
```json
{
  "strategy": {
    "name": "ma_crossover",
    "params": {
      "fast_period": 10,
      "slow_period": 20,
      "position_size": 0.1
    }
  },
  "bot": {
    "long": {
      // 策略特定参数
    },
    "short": {
      // 策略特定参数
    }
  }
}
```

#### 2. 动态策略加载
```python
# src/strategies/dynamic_loader.py
import importlib
import os
from typing import Dict, Any

class DynamicStrategyLoader:
    """动态策略加载器"""
    
    def __init__(self, strategies_dir: str = "strategies"):
        self.strategies_dir = strategies_dir
        self.loaded_strategies = {}
    
    def load_strategy_from_file(self, file_path: str, strategy_name: str):
        """从文件加载策略"""
        spec = importlib.util.spec_from_file_location(strategy_name, file_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        
        # 假设策略类名与文件名相同
        strategy_class = getattr(module, strategy_name)
        self.loaded_strategies[strategy_name] = strategy_class
        
        return strategy_class
    
    def load_all_strategies(self):
        """加载所有策略文件"""
        strategies_path = os.path.join(os.path.dirname(__file__), self.strategies_dir)
        
        for file_name in os.listdir(strategies_path):
            if file_name.endswith('.py') and not file_name.startswith('_'):
                strategy_name = file_name[:-3]  # 移除.py扩展名
                file_path = os.path.join(strategies_path, file_name)
                self.load_strategy_from_file(file_path, strategy_name)
```

## 实施步骤

### 第一步：创建策略目录结构
```
src/
├── strategies/
│   ├── __init__.py
│   ├── base_strategy.py
│   ├── strategy_manager.py
│   ├── default_strategy.py
│   ├── ma_crossover_strategy.py
│   ├── rsi_strategy.py
│   └── custom_strategies/
│       ├── __init__.py
│       └── my_strategy.py
```

### 第二步：修改Passivbot类
1. 添加策略管理器初始化
2. 修改订单计算逻辑
3. 添加策略参数传递

### 第三步：创建策略配置
```json
{
  "strategy": {
    "name": "ma_crossover",
    "params": {
      "fast_period": 10,
      "slow_period": 20,
      "position_size": 0.1
    }
  }
}
```

### 第四步：测试策略
1. 创建回测配置
2. 运行策略回测
3. 优化策略参数

## 策略开发最佳实践

### 1. 策略设计原则
- **单一职责**: 每个策略只负责一种交易逻辑
- **参数化**: 所有关键参数都应该可配置
- **错误处理**: 完善的异常处理机制
- **日志记录**: 详细的策略执行日志

### 2. 性能优化
- **缓存计算**: 缓存重复计算结果
- **向量化**: 使用NumPy进行向量化计算
- **异步处理**: 对于IO密集型操作使用异步

### 3. 风险管理
- **仓位限制**: 设置最大仓位大小
- **止损机制**: 实现止损逻辑
- **资金管理**: 合理的资金分配

### 4. 测试策略
- **单元测试**: 测试策略的各个组件
- **回测验证**: 使用历史数据验证策略
- **压力测试**: 测试极端市场条件下的表现

## 总结

Passivbot项目目前**没有内置的策略插拔能力**，但可以通过以下方式实现：

1. **Python策略插件系统**（推荐）- 易于开发和测试
2. **Rust策略扩展** - 高性能，但开发复杂度高
3. **配置文件驱动** - 灵活的参数配置

建议采用**Python策略插件系统**，因为它：
- 开发简单，易于理解
- 可以复用现有的Rust组件
- 支持动态加载和热更新
- 便于调试和测试

通过这种方式，你可以轻松地实现自己的交易策略，同时保持与Passivbot现有架构的兼容性。

---

*本指南提供了完整的自定义策略开发方案，可以根据具体需求选择合适的实现方式*
